\documentclass[10pt, a4paper]{arbeitsblatt}

\ladeModule{theme,boxen}
\ladeFach[algorithmen,listings,uml]{informatik}

\aboptionen{
	name		= {J. Neugebauer},
	kuerzel		= {Ngb},
	titel		= {Struktogramme},
	reihe		= {Lineare dynamische Datenstrukturen},
	fach		= {Informatik},
	lerngruppe	= {Q1},
	nummer		= {II.02},
	lizenz		= {cc-by-nc-sa-4},
	version		= {2022-09-21},
}

\begin{document}
\ReiheTitel

\begin{infobox}
	Aufgabe eines \textbf{Struktogrammes} ist es, den Ablauf eines Computerprogramms
	auf dem Papier darzustellen. Dazu wurden in den 70er Jahren des vergangenen
	Jahrhunderts von \person{Isaac Nassi} und \person{Ben Shneidermann} grafische
	Grundelemente entwickelt, die es ermöglichen sollten, Programmabläufe ohne
	Sprunganweisungen darzustellen. Die Notwendigkeit ergab sich daraus, dass im
	Laufe der Zeit Computerprogramme immer komplexer und damit unübersichtlicher
	geworden waren. Mit der Einführung von Struktogrammen wurde es erforderlich,
	die Programmlogik wieder gründlich und ohne Sprünge zu planen. Man bezeichnete
	dies als \textbf{strukturierte Programmierung}.

	In der professionellen Softwareentwicklung werden Struktogramme eher selten
	eingesetzt. Dort werden eher die \emph{Aktivitätsdiagramme} der UML verwendet.
\end{infobox}

\begin{aufgabe}[subtitle=Operationen der Schlange]
Unten siehst du das Struktogramm der Operation
\code{dequeue}. Analysiere den Aufbau und beschreibe seine Elemente. Was ist
das besondere an dieser Art der Darstellung von Algorithmen? Wo könnten Vor-
und Nachteile liegen? Ergänze dann die schon bekannte
\code{enqueue}-Operation. (Hilfe findest du im Buch.)
\end{aufgabe}

\subsection*{enqueue-Operation}
\begin{rahmen}
	\vspace{5cm}
\end{rahmen}

\subsection*{dequeue-Operation}

\begin{center}
	\ttfamily\small
	\begin{struktogramm}(120,32)
		\ifthen{4}{6}{head != tail}
		\instruction[8]{head = head.getNext()}
		\change
		\ifthen{5}{5}{head != null}
		\instruction[8]{head = null}
		\instruction[8]{tail = null}
		\change
		%empty
		\ifend
		\ifend
	\end{struktogramm}
\end{center}

\clearpage
\ReiheTitel

Der generische Stapel besteht aus einer Klasse \code{Stack<ContentType>} und
einer Klasse \code{Node<ContentType>}.

\begin{center}
	\begin{tikzpicture}\small
		\begin{class}[text width=6cm]{Stack<ContentType>}{0,0}
			\operation{+ push(content : ContentType) : void}
			\operation{+ pop() : void}
			\operation{+ isEmpty() : boolean}
			\operation{+ top() : ContentType}
		\end{class}
		\begin{class}[text width=7cm]{Node<ContentType>}{8.5,0}
			\attribute{- content : ContentType}
			\operation{+ setNext(pNext : Node<ContentType>) : void}
			\operation{+ getNext() : Node<ContentType>}
			\operation{+ getContent() : ContentType}
		\end{class}
		\uses{Stack<ContentType>}{head}{0,1}{Node<ContentType>}
		\usesself{Node<ContentType>}{next}{0,1}
	\end{tikzpicture}
\end{center}

\begin{aufgabe}
Unten sind die Operationen \code{push} und \code{pop}
als \emph{Pseudocode} abgebildet.
\begin{enuma}
	\item \operator{Analysiere} ihren Aufbau und \operator{erkläre} das \emph{Verkettungsprinzip} der Datenstruktur \emph{Stapel} anhand eines Beispiels.
	\item \operator{Überführe} den Pseudocode der beiden Operationen in entsprechende \emph{Struktogramme}.
\end{enuma}

\subsection*{push-Operation}
\begin{lstlisting}
Wenn Stapel leer
	erstelle einen neuen Knoten mit dem neuen Inhalt
	setze head auf den neuen Knoten
Sonst
	erstelle einen neuen Knoten mit dem neuen Inhalt
	setze den Nachfolger des neuen Knotens auf head
	setze head auf den neuen Knoten
Ende Wenn
\end{lstlisting}

\subsection*{pop-Operation}
\begin{lstlisting}
Wenn Stapel nicht leer
	setze head auf den Nachfolger von head
Ende Wenn
\end{lstlisting}
\end{aufgabe}

\end{document}
